---
title: "Securing FastAPI Applications with PKCE"
date: "2025-11-19"
excerpt: "Securing FastAPI applications with PKCE using FastAPI-azure-auth on Azure."
bannerUrl: "/blog/2025-11-19/banner.png"
bannerUrlDark: "/blog/2025-11-19/banner-dark.png"
tags: ["blog", "FastAPI", "PKCE", "authentication", "Azure"]
featured: true
readTime: "12 min read"
---

Authentication is a critical component of modern web applications, and implementing it securely can be challenging. When building APIs with FastAPI and deploying to Azure, the combination of OAuth 2.0 with PKCE (Proof Key for Code Exchange) provides a robust security layer for your applications.

In this guide, we'll walk through implementing secure authentication in FastAPI using the `fastapi-azure-auth` library, which simplifies Azure AD integration while maintaining best security practices with PKCE.

![Banner](/blog/2025-11-19/banner.png)

# Why PKCE Matters for Security

PKCE (pronounced "pixy") was originally designed to protect mobile and native applications, but it's now recommended for all OAuth 2.0 clients, including web applications. Here's why:

## The Problem with Traditional OAuth 2.0

The traditional Authorization Code flow has a vulnerability: the authorization code can be intercepted by malicious actors. If an attacker obtains this code, they can exchange it for an access token.

## How PKCE Solves This

PKCE adds an extra layer of security by introducing two components:

1. **Code Verifier**: A cryptographically random string generated by the client
2. **Code Challenge**: A transformed version of the code verifier (typically using SHA-256)

The flow works as follows:

```
1. Client generates code_verifier and code_challenge
2. Client sends code_challenge to authorization server
3. Authorization server stores code_challenge
4. Client receives authorization code
5. Client sends authorization code + code_verifier
6. Server verifies code_verifier matches stored code_challenge
7. Server issues access token
```

This ensures that even if an attacker intercepts the authorization code, they cannot exchange it for a token without the original code verifier.

## Key Security Benefits

- **Protection against authorization code interception attacks**
- **No need for client secrets** (suitable for public clients)
- **Mitigation of code injection attacks**
- **Enhanced security for SPAs and mobile apps**

# Understanding Authentication Flows

Before diving into implementation, it's important to understand the different OAuth 2.0 flows and when to use each:

## Authorization Code Flow with PKCE (Recommended)

**Use when:**

- Building single-page applications (SPAs)
- Developing mobile or native applications
- Creating public clients that cannot securely store secrets
- You want the highest level of security

**Characteristics:**

- User authentication happens in browser
- Access tokens are obtained securely
- Refresh tokens can be used for long-lived sessions

## Client Credentials Flow

**Use when:**

- Building server-to-server communication
- Creating daemon applications or background services
- No user interaction is required

**Characteristics:**

- Uses client ID and client secret
- No user context
- Suitable for trusted backend services

## Implicit Flow (Deprecated)

**Avoid this flow:** The implicit flow is now considered insecure and has been deprecated in favor of Authorization Code Flow with PKCE.

# Setting Up Azure AD Application

Before we can implement authentication in FastAPI, we need to configure an application in Azure Active Directory.

## Step 1: Register a New Application

1. Navigate to the [Azure Portal](https://portal.azure.com)
2. Go to **Azure Active Directory** > **App registrations**
3. Click **New registration**

**Screenshot placeholder: Azure AD App Registration page**

Fill in the following details:

```
Name: your-fastapi-app
Supported account types: Accounts in this organizational directory only
Redirect URI: Web - http://localhost:8000/auth/callback
```

## Step 2: Configure Authentication Settings

After creating the application, configure the authentication settings:

1. Go to **Authentication** in the left menu
2. Under **Implicit grant and hybrid flows**, ensure both are **unchecked** (we're using PKCE)
3. Under **Advanced settings**, set **Allow public client flows** to **Yes**

**Screenshot placeholder: Authentication configuration page showing PKCE settings**

## Step 3: Configure API Permissions

1. Navigate to **API permissions**
2. Click **Add a permission**
3. Select **Microsoft Graph**
4. Choose **Delegated permissions**
5. Add the following permissions:
   - `User.Read`
   - `openid`
   - `profile`
   - `email`

**Screenshot placeholder: API permissions configuration**

## Step 4: Note Your Application Details

You'll need the following information for your FastAPI configuration:

```
Application (client) ID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
Directory (tenant) ID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
```

**Screenshot placeholder: Application overview page with client ID and tenant ID highlighted**

# Installing FastAPI-azure-auth

The `fastapi-azure-auth` library simplifies Azure AD integration with FastAPI. Install it along with required dependencies:

```bash
pip install fastapi-azure-auth
pip install "fastapi[all]"
pip install python-multipart
```

Or add to your `requirements.txt`:

```txt
fastapi[all]==0.104.1
fastapi-azure-auth==4.3.0
python-multipart==0.0.6
uvicorn[standard]==0.24.0
```

Install with:

```bash
pip install -r requirements.txt
```

# Step-by-Step Implementation

## Step 1: Configure Environment Variables

Create a `.env` file to store your Azure AD configuration:

```env
AZURE_TENANT_ID=your-tenant-id
AZURE_CLIENT_ID=your-client-id
APP_CLIENT_ID=your-client-id
OPENAPI_CLIENT_ID=your-client-id
```

## Step 2: Create Configuration Module

Create a `config.py` file to manage your settings:

```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    AZURE_TENANT_ID: str
    AZURE_CLIENT_ID: str
    APP_CLIENT_ID: str
    OPENAPI_CLIENT_ID: str
    BACKEND_CORS_ORIGINS: list[str] = ["http://localhost:3000", "http://localhost:8000"]

    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
```

## Step 3: Initialize FastAPI with Azure Auth

Create your main `app.py`:

```python
from fastapi import FastAPI, Depends, Security
from fastapi.middleware.cors import CORSMiddleware
from fastapi_azure_auth import SingleTenantAzureAuthorizationCodeBearer
from fastapi_azure_auth.user import User
from config import settings

# Initialize FastAPI app
app = FastAPI(
    title="My Secure API",
    description="FastAPI with Azure AD authentication",
    version="1.0.0",
    swagger_ui_oauth2_redirect_url="/oauth2-redirect",
    swagger_ui_init_oauth={
        "usePkceWithAuthorizationCodeGrant": True,
        "clientId": settings.OPENAPI_CLIENT_ID,
        "scopes": "api://default/.default",
    },
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.BACKEND_CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize Azure AD auth with PKCE
azure_scheme = SingleTenantAzureAuthorizationCodeBearer(
    app_client_id=settings.APP_CLIENT_ID,
    tenant_id=settings.AZURE_TENANT_ID,
    scopes={
        f"api://{settings.APP_CLIENT_ID}/user_impersonation": "User impersonation",
    },
    allow_guest_users=False,
)
```

## Step 4: Create Protected Endpoints

Now let's create some protected endpoints:

```python
@app.get("/")
async def root():
    """Public endpoint - no authentication required"""
    return {
        "message": "Welcome to the API",
        "status": "public"
    }

@app.get("/api/me")
async def get_current_user(user: User = Depends(azure_scheme)) -> dict:
    """Protected endpoint - returns current user info"""
    return {
        "user_id": user.sub,
        "username": user.preferred_username,
        "name": user.name,
        "email": user.email,
        "roles": user.roles if hasattr(user, 'roles') else []
    }

@app.get("/api/protected")
async def protected_route(user: User = Depends(azure_scheme)) -> dict:
    """Protected endpoint - requires authentication"""
    return {
        "message": f"Hello {user.name}!",
        "status": "authenticated",
        "access_level": "protected"
    }
```

## Step 5: Add Role-Based Access Control

For more granular control, implement role-based access:

```python
from fastapi import HTTPException, status

def require_role(required_role: str):
    """Dependency to check for specific role"""
    async def role_checker(user: User = Depends(azure_scheme)) -> User:
        if not hasattr(user, 'roles') or required_role not in user.roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"User does not have required role: {required_role}"
            )
        return user
    return role_checker

@app.get("/api/admin")
async def admin_only(user: User = Depends(require_role("Admin"))) -> dict:
    """Admin-only endpoint"""
    return {
        "message": "Welcome to admin panel",
        "user": user.name,
        "access_level": "admin"
    }
```

## Step 6: Handle Startup and Shutdown Events

Add lifecycle events for loading and caching Azure AD configuration:

```python
@app.on_event("startup")
async def load_config() -> None:
    """
    Load OpenID config and cache it on startup.
    This improves performance by avoiding repeated calls to Azure AD.
    """
    await azure_scheme.openid_config.load_config()

@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on shutdown"""
    # Close any open connections, cleanup resources
    pass
```

## Complete Example

Here's the complete `app.py`:

```python
from fastapi import FastAPI, Depends, Security, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi_azure_auth import SingleTenantAzureAuthorizationCodeBearer
from fastapi_azure_auth.user import User
from config import settings

app = FastAPI(
    title="My Secure API",
    description="FastAPI with Azure AD authentication using PKCE",
    version="1.0.0",
    swagger_ui_oauth2_redirect_url="/oauth2-redirect",
    swagger_ui_init_oauth={
        "usePkceWithAuthorizationCodeGrant": True,
        "clientId": settings.OPENAPI_CLIENT_ID,
        "scopes": "api://default/.default",
    },
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.BACKEND_CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

azure_scheme = SingleTenantAzureAuthorizationCodeBearer(
    app_client_id=settings.APP_CLIENT_ID,
    tenant_id=settings.AZURE_TENANT_ID,
    scopes={
        f"api://{settings.APP_CLIENT_ID}/user_impersonation": "User impersonation",
    },
    allow_guest_users=False,
)

@app.on_event("startup")
async def load_config() -> None:
    await azure_scheme.openid_config.load_config()

@app.get("/")
async def root():
    return {"message": "Welcome to the API", "status": "public"}

@app.get("/api/me")
async def get_current_user(user: User = Depends(azure_scheme)) -> dict:
    return {
        "user_id": user.sub,
        "username": user.preferred_username,
        "name": user.name,
        "email": user.email,
    }

@app.get("/api/protected")
async def protected_route(user: User = Depends(azure_scheme)) -> dict:
    return {
        "message": f"Hello {user.name}!",
        "status": "authenticated"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

# Testing Your Implementation

## Manual Testing with Swagger UI

FastAPI automatically generates interactive API documentation with Swagger UI, which makes testing OAuth 2.0 with PKCE straightforward:

1. Start your FastAPI application:

```bash
uvicorn app:app --reload
```

2. Navigate to `http://localhost:8000/docs`
3. Click the **Authorize** button at the top right
4. The OAuth 2.0 authorization window will appear
5. Click **Authorize** and log in with your Azure AD credentials

**Screenshot placeholder: Swagger UI with Authorize button highlighted**

**Screenshot placeholder: OAuth 2.0 authorization dialog with PKCE enabled**

6. After successful authentication, try accessing the protected endpoints

## Testing with cURL

You can also test using cURL, though you'll need to obtain a token first:

```bash
# First, get your access token from Azure AD
# Then use it in your requests
curl -X GET "http://localhost:8000/api/me" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

## Automated Testing

Create a `test_auth.py` file for automated tests:

```python
import pytest
from fastapi.testclient import TestClient
from app import app
from unittest.mock import Mock, patch

client = TestClient(app)

def test_public_endpoint():
    """Test that public endpoints are accessible without auth"""
    response = client.get("/")
    assert response.status_code == 200
    assert response.json()["status"] == "public"

def test_protected_endpoint_without_auth():
    """Test that protected endpoints reject unauthenticated requests"""
    response = client.get("/api/me")
    assert response.status_code == 401

@patch("fastapi_azure_auth.SingleTenantAzureAuthorizationCodeBearer.__call__")
def test_protected_endpoint_with_auth(mock_auth):
    """Test that protected endpoints work with valid authentication"""
    # Mock the user object
    mock_user = Mock()
    mock_user.sub = "user-123"
    mock_user.name = "Test User"
    mock_user.email = "test@example.com"
    mock_user.preferred_username = "testuser"
    mock_auth.return_value = mock_user

    response = client.get("/api/me")
    assert response.status_code == 200
    assert response.json()["name"] == "Test User"
```

Run tests with:

```bash
pytest test_auth.py -v
```

# Troubleshooting Common Issues

## Issue 1: "AADSTS50011: The reply URL specified in the request does not match"

**Cause:** The redirect URI in your code doesn't match what's configured in Azure AD.

**Solution:**

1. Check your redirect URI in Azure AD (must exactly match, including trailing slashes)
2. Ensure your FastAPI app uses the same URL
3. Update `swagger_ui_oauth2_redirect_url` to match

```python
app = FastAPI(
    swagger_ui_oauth2_redirect_url="/oauth2-redirect",  # Must match Azure AD config
)
```

**Screenshot placeholder: Azure AD redirect URI configuration**

## Issue 2: "AADSTS7000218: request_uri validation failed"

**Cause:** PKCE parameters are not being sent correctly.

**Solution:**
Ensure PKCE is enabled in Swagger UI configuration:

```python
swagger_ui_init_oauth={
    "usePkceWithAuthorizationCodeGrant": True,  # This is critical
    "clientId": settings.OPENAPI_CLIENT_ID,
}
```

## Issue 3: "401 Unauthorized" on All Protected Endpoints

**Cause:** Token validation is failing.

**Solution:**

1. Verify your `APP_CLIENT_ID` and `TENANT_ID` are correct
2. Check that the token audience matches your application
3. Ensure OpenID config is loaded on startup:

```python
@app.on_event("startup")
async def load_config():
    await azure_scheme.openid_config.load_config()
```

## Issue 4: CORS Errors in Browser

**Cause:** Your frontend origin is not allowed by CORS policy.

**Solution:**
Add your frontend URL to `BACKEND_CORS_ORIGINS`:

```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Add your frontend URL
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

## Issue 5: "Token has expired"

**Cause:** Access tokens have a limited lifetime (typically 1 hour).

**Solution:**
Implement token refresh logic:

```python
from fastapi_azure_auth import SingleTenantAzureAuthorizationCodeBearer

# Configure with refresh token support
azure_scheme = SingleTenantAzureAuthorizationCodeBearer(
    app_client_id=settings.APP_CLIENT_ID,
    tenant_id=settings.AZURE_TENANT_ID,
    scopes={
        f"api://{settings.APP_CLIENT_ID}/user_impersonation": "User impersonation",
        "offline_access": "Refresh token",  # Enable refresh tokens
    },
)
```

## Debug Mode

Enable debug logging to troubleshoot issues:

```python
import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("fastapi_azure_auth")
logger.setLevel(logging.DEBUG)
```

# Conclusion

Implementing OAuth 2.0 with PKCE in FastAPI using Azure AD provides a robust, secure authentication mechanism for your applications. By following this guide, you've learned:

- âœ… Why PKCE is essential for modern application security
- âœ… How to configure Azure AD applications for PKCE
- âœ… Step-by-step implementation with `fastapi-azure-auth`
- âœ… Testing strategies for authenticated endpoints
- âœ… Common troubleshooting techniques

## Best Practices Summary

1. **Always use PKCE** for public clients (SPAs, mobile apps)
2. **Load OpenID config on startup** to improve performance
3. **Implement proper error handling** for authentication failures
4. **Use environment variables** for sensitive configuration
5. **Test both authenticated and unauthenticated scenarios**
6. **Implement token refresh** for better user experience
7. **Use role-based access control** for fine-grained permissions

## Next Steps

- Implement refresh token rotation for enhanced security
- Add logging and monitoring for authentication events
- Set up automated testing in your CI/CD pipeline
- Configure Azure AD groups for role-based access
- Implement multi-tenant support if needed

## Additional Resources

- [FastAPI-azure-auth Documentation](https://github.com/Intility/fastapi-azure-auth)
- [OAuth 2.0 PKCE RFC](https://tools.ietf.org/html/rfc7636)
- [Azure AD Authentication Documentation](https://docs.microsoft.com/en-us/azure/active-directory/)
- [FastAPI Security Documentation](https://fastapi.tiangolo.com/tutorial/security/)

Happy coding, and stay secure! ðŸ”’
